import {
  action,
  computed,
  observable,
  reaction,
  runInAction,
} from 'mobx'

import akasha from 'akasha'

import LineItem from './LineItem'
import Order from './Order'
import User from './User'

import type {
  ICart,
  ICartAPI,
  IClient,
  ICoupon,
  IGeoRate,
  IOrder,
  IPayment,
  IUser,
} from './types'

import {
  log
} from './utils'

export type CartUpdateRequest = [string, number, boolean, boolean, boolean]
export type AnalyticsProductTransformFn = (v: any) => any

/**
 * Cart keeps track of items being added and removed from the cart/order
 */
export default class Commerce implements ICartAPI {
  /**
   * metadata of the current cart
   */
  @observable
  cart: ICart = {
    id: '',
    storeId: '',
    email: '',
    name: '',
  }

  /**
   * client is reference to a IClient
   */
  @observable
  client: IClient

  /**
   * updateQueue contains the list of cart item updates so we can ensure
   * updates are pushed fifo
   */
  @observable
  updateQueue: CartUpdateRequest[] = []

  /**
   * updateQueuePromise is a reference to the promise generated by the
   * updateQueue for the purposes of awaiting outside of the direct call
   */
  @observable
  updateQueuePromise: Promise<void> = new Promise((res) => { res() })

  /**
   * order is the object for tracking the user's order/cart info
   */
  @observable
  order: Order

  /**
   * user is an object for tracking the user's contact information
   */
  @observable
  user: User

  /**
   * payment is the object for tracking the user's payment information
   */
  @observable
  payment: any = {}

  /**
   * payment is the object for tracking the user's payment information
   */
  @observable
  analytics: any

  /**
   * analyticsProductTransform is a function for transforming analytics objects
   * before sending them
   */
  @observable
  analyticsProductTransform: AnalyticsProductTransformFn

  /**
   * bootstrapPromise executes after contructor completes any bootstrap
   */
  @observable
  bootstrapPromise: Promise<any>

  /**
   * the current storeId
   */
  @observable
  _storeId: string

  /**
   * Create an instance of Commerce
   * @param client is the http client for talking to carts
   * @param order is the default order configuration
   * @param taxRates is an array of IGeoRates for taxes
   * @param shippingRates is an array of IGeoRates for taxes
   * @param analytics is the call to the analytics library
   * @param aPT is a function for transforming analytics objects before sending
   * them
   */
  constructor(
    client: IClient,
    order?: any,
    taxRates: IGeoRate[] = [],
    shippingRates: IGeoRate[] = [],
    analytics: any = undefined,
    aPT: AnalyticsProductTransformFn = (v) => v,
  ) {
    this.client = client
    this.order = order ? new Order(order, taxRates, shippingRates, client, this) : Order.load(client, taxRates, shippingRates, this)
    this._storeId = order ? order.storeId : ''
    this.user = new User({}, this)
    this.analytics = analytics
    this.analyticsProductTransform = aPT

    this.bootstrapPromise = this.order.bootstrapPromise
    // this.cartInit()
  }

  /**
   * @return the items on the order
   */
  @computed
  get items(): LineItem[] {
    return this.order.items ?? []
  }

  /**
   * @return the number of items on the order
   */
  @computed
  get size(): number {
    return this.order.size
  }

  /**
   * Get the cart id
   * @return the cartId of the current cart from storage.  If there is no
   * current cart, return empty
   */
  @computed
  get cartId(): string {
    return akasha.get('cart.id') ?? ''
  }

  /**
   * Get the cart id
   */
  @computed
  get isCartInit(): boolean {
    return !!this.cartId
  }

  @observable
  async setStoreId(sId: string): Promise<void> {
    this._storeId = sId
    this.order.storeId = sId

    // refresh all items
    const ps = this.items.map((li) => {
      return this.refresh(li.id)
    })

    this.cartSetStore(sId)

    await Promise.all(ps)
  }

  @computed
  get storeId() : string {
    return this._storeId
  }

  /**
   * Initialize the cart system.
   * @return initialized or recovered cart instance
   */
  @action
  async cartInit(): Promise<ICart> {
    // check for if the cartId exists and either create a new cart or load cart
    // id
    if (!this.isCartInit) {
      this.cart = await this.client.cart.create()
      akasha.set('cart', this.cart)
    } else {
      this.cart.id = this.cartId
    }

    runInAction(() => {
      this.order = new Order(akasha.get('order'), [], [], this.client, this)
    })

    return this.cart
  }

  /**
   * Get the current state of a specific lineitem
   * @param id the product id of a lineitem
   * @return lineitem or undefined if product isn't in cart
   */
  async get(id: string, ): Promise<LineItem | undefined> {
    // Check the item on the order
    let item = this.order.get(id)

    if (item) {
      return item
    }

    // Check the item in the queue
    for (const request of this.updateQueue) {
      if (request[0] !== id) {
        continue
      }

      // TODO: we should await the update queue and await instead
      const li = new LineItem({
        id: request[0],
        quantity: request[1],
        locked: request[2],
        ignore: request[3],
        storeId: this.storeId,
      }, this.client)

      try {
        await li.bootstrapPromise
      } catch (err) {
        log('get error', err)
        return
      }

      return li
    }
  }

  /**
   * Set a lineitem by product id.  Add lineitem to asynchronous update queue
   * @param id productId
   * @param quantity amount of productId in cart
   * @param locked is this lineitem modifiable in the UI
   * @param ignore is this lineitem ignored by the UI (loading in progress,
   * freebie etc)
   * @return promise for when all set operations are completed
   */
  @action
  async set(id: string, quantity: number, locked=false, ignore=false, force=false): Promise<void> {
    if (this.updateQueue.length === 0) {
      this.updateQueue.push([id, quantity, locked, ignore, force])
      this.updateQueuePromise = this.executeUpdates()
      await this.updateQueuePromise
    } else {
      this.updateQueue.push([id, quantity, locked, ignore, force])
      await this.updateQueuePromise
    }
  }

  /**
   * Refresh a lineitem by product id.  Add lineitem to asynchronous update queue
   * @return return the LineItem if it exists or nothing if it doesn't.
   */
  @action
  async refresh(id: string): Promise<LineItem | undefined> {
    // console.log('refresh', id)
    let item = await this.get(id)
    if (item) {
      await this.set(id, item.quantity, item.locked, item.ignore, true)
      // console.log('refresh2', id)
      return await this.get(id)
    }
  }

  /**
   * Execute all queued updates
   * @return promise for when all queued updates are done
   */
  @action
  async executeUpdates(): Promise<void> {
    const items = this.items

    if (!this.updateQueue.length) {
      return
    }

    let updateQueueRequest = this.updateQueue[0]

    // Resolve or escape if empty queue
    if (!updateQueueRequest) {
      this.updateQueue.shift()
      return
    }

    let [id, quantity, locked, ignore, force] = updateQueueRequest
    // log('eu', id)

    // Resolve or escape if itemless mode
    if (this.order.inItemlessMode && quantity > 0 && !force) {
      this.updateQueue.shift()
      return await this.executeUpdates()
    }

    // log('eu2')

    // handle negative quantities.
    if (quantity < 0) {
      this.updateQueue.shift()
      quantity = 0
    }

    // delete item
    if (quantity === 0) {
      await this.del(id)
      this.updateQueue.shift()
      return await this.executeUpdates()
    }

    // log('eu3')

    // console.log('eu', updateQueueRequest)

    // try and update item quantity
    if (await this.executeUpdateItem(id, quantity, locked, ignore) != null) {
      this.updateQueue.shift()
      return await this.executeUpdates()
    }

    // log('eu4')

    // Fetch up to date information at time of checkout openning
    // TODO: Think about revising so we don't report old prices if they changed after checkout is open

    const li = new LineItem({
      id,
      quantity,
      locked,
      ignore,
      storeId: this.storeId,
    }, this.client)

    // log('eu4.5')

    try {
      await li.bootstrapPromise
    } catch (err) {
      log('set error', err)
      this.updateQueue.shift()
      return await this.executeUpdates()
    }

    // log('eu5', this.analytics)

    runInAction(() => {
      items.push(li)

      let a = {
        id: li.productId,
        sku: li.productSlug,
        name: li.productName,
        quantity: quantity,
        price: li.price / 100
      }

      if (this.analytics)  {
        if (this.analyticsProductTransform != null) {
          a = this.analyticsProductTransform(a)
        }

        this.analytics.track('Added Product', a)
      }
    })

    await this.cartSetItem(li.productId, quantity)

    this.updateQueue.shift()
    return this.executeUpdates()
  }

  /**
   * Execute update for item
   * @param id productId
   * @param quantity amount of productId in cart
   * @param locked is this lineitem modifiable in the UI
   * @param ignore is this lineitem ignored by the UI (loading in progress,
   * freebie etc)
   * @return LineItem if item is updated or undefined if something was invalid
   */
  @action
  async executeUpdateItem(id: string, quantity: number, locked: boolean, ignore: boolean): Promise<LineItem | undefined> {
    // console.log('eui', id)

    log('eui', id)
    const items = this.items

    for (const k in items) {
      let item = items[k]
      // ignore if not a match to id
      if (
        item.id !== id &&
        item.productId !== id &&
        item.productSlug !== id &&
        item.storeId === this.storeId
      ) {
        continue
      }

      if (item.storeId !== this.storeId) {
        // console.log('eui2', item.storeId, this.storeId)

        item = new LineItem({
          id,
          quantity,
          locked,
          ignore,
          storeId: this.storeId,
        }, this.client)

        items[k] = item

        try {
          await item.bootstrapPromise
        } catch (err) {
          log('setItem storeId update error', err)
        }
      }

      // log('eu4.5')

      const oldValue = item.quantity

      item.quantity = quantity
      item.locked = locked
      item.ignore = ignore

      const newValue = quantity

      const deltaQuantity = newValue - oldValue
      if (deltaQuantity > 0) {
        let a = {
          id: item.productId,
          sku: item.productSlug,
          name: item.productName,
          quantity: deltaQuantity,
          price: item.price / 100
        }

        if (this.analytics)  {
          if (this.analyticsProductTransform != null) {
            a = this.analyticsProductTransform(a)
          }

          this.analytics.track('Added Product', a)
        }

        this.cartSetItem(item.productId, quantity)
      } else if (deltaQuantity < 0) {
        let a = {
          id: item.productId,
          sku: item.productSlug,
          name: item.productName,
          quantity: deltaQuantity,
          price: item.price / 100
        }

        if (this.analytics)  {
          if (this.analyticsProductTransform != null) {
            a = this.analyticsProductTransform(a)
          }

          this.analytics.track('Removed Product', a)
        }
      }

      this.items[k].quantity =  quantity
      this.items[k].locked = locked
      this.items[k].ignore = ignore

      await this.cartSetItem(item.productId, quantity)

      return this.items[k]
    }
  }

  /**
   * Delete an item
   * @param id productId
   * @return LineItem that was deleted
   */
  @action
  async del(id: string): Promise<LineItem | undefined> {
    const items = this.items
    let itemToDeleteIndex: number = items.length

    for (const k in items) {
      const item = items[k]
      if(
        item.productId === id ||
        item.productSlug === id ||
        item.id === id
      ) {
        itemToDeleteIndex = parseInt(k)
        break
      }
    }

    if (itemToDeleteIndex >= items.length) {
      return
    }

    const item = items[itemToDeleteIndex]

    // Remove the itemToDelete from the items list
    this.items.splice(itemToDeleteIndex, 1)

    let a: any = {
      id: item.productId,
      sku: item.productSlug,
      name: item.productName,
      quantity: item.quantity,
      price: item.price / 100,
    }

    if (this.analytics)  {
      if (this.analyticsProductTransform != null) {
        a = this.analyticsProductTransform(a)
      }

      this.analytics.track('Removed Product', a)
    }

    await this.cartSetItem(item.productId, 0)

    runInAction(() => {
      item.quantity = 0
    })

    return item
  }

  /**
   * Set the cart's items directly on the server (shouldn't be used directly in high level
   * operations)
   * @param id productId
   * @param quantity of product
   * @return ICart returned from server
   */
  @action
  async cartSetItem(id: string, quantity: number): Promise<ICart | undefined> {
    if (this.isCartInit) {
      // console.log('cart item')
      this.cart.id = this.cartId
      return this.client.cart.set({
        id: this.cartId,
        productId: id,
        quantity: quantity,
        storeId: this.storeId,
      })
    }
  }

  /**
   * Set the cart's store directly on the server (shouldn't be used directly in high level
   * operations)
   * @param storeId id of the store
   * @return ICart returned from server
   */
  @action
  async cartSetStore(storeId: string): Promise<ICart | undefined> {
    if (this.isCartInit) {
      this.cart.id = this.cartId
      this.cart.storeId = storeId || this.storeId
      return this.client.cart.update(this.cart)
    }
  }

  /**
   * Set the cart's email directly on the server (shouldn't be used directly in high level
   * operations)
   * @param email user email
   * @return ICart returned from server
   */
  @action
  async cartSetEmail(email: string): Promise<ICart | undefined> {
    if (this.isCartInit) {
      this.cart.id = this.cartId
      this.cart.email = this.user.email
      return this.client.cart.update(this.cart)
    }
  }

  /**
   * Set the cart's user name directly on the server (shouldn't be used directly in high level
   * operations)
   * @param name user's name
   * @return ICart returned from server
   */
  @action
  async cartSetName(name: string): Promise<ICart | undefined> {
    if (this.isCartInit) {
      this.cart.id = this.cartId
      this.cart.name = name
      return this.client.cart.update(this.cart)
    }
  }

  /**
   * Set the cart's user name directly on the server (shouldn't be used directly in high level
   * operations)
   * @param name user's name
   * @return ICart returned from server
   */
  @action
  async clear(): Promise<void>{
    this.updateQueue.length = 0
    const itemsClone = this.items.slice(0)

    await Promise.all(itemsClone.map((item) => this.set(item.productId, 0)))

    return
  }

  /**
   * Apply a coupon/promoCode
   * @param code coupon code/ID
   * @return ICoupon returned from server
   */
  @action
  async setCoupon(code?: string): Promise<ICoupon | undefined> {
    if (code) {
      try {
        let coupon = await this.client.coupon.get(code)
        if (!coupon.enabled) {
          return
        }

        runInAction(() => {
          this.order.coupon = coupon
          this.order.couponCodes = [code]
        })

        if (coupon.freeProductId) {
          await this.client.product.get(coupon.freeProductId)
        }

        return coupon
      } catch (err) {
        log('promoCode error', err)

        throw err
      }
    }
  }

  /**
   * Checkout the order
   * @param payment contains the user's credit card credentials
   * @return IOrder returned from server's capture endpoint
   */
  @action
  async checkout(payment: IPayment): Promise<IOrder | undefined> {
    // TODO: Add support for referral programs back
    let order: IOrder = Object.assign({}, this.order.data)
    let user: IUser = Object.assign({}, this.user)

    let opts = {
      order,
      payment,
      user,
    }

    try {
      let authorizedOrder = await this.client.checkout.authorize(opts)

      if (authorizedOrder) {
        runInAction(() => {
          this.order.id = (authorizedOrder as IOrder).id
          this.order.userId = (authorizedOrder as IOrder).userId
        })

        let capturedOrder = await this.client.checkout.capture(this.order.id)

        if (!capturedOrder) {
          throw new Error('Checkout failed for unknown reasons, please try again later.')
        }

        runInAction(() => {
          this.order.number = (capturedOrder as IOrder).number
        })

        let options = {
          orderId:  capturedOrder.id,
          total:    capturedOrder.total / 100,
          // revenue: parseFloat(order.total/100),
          shipping: capturedOrder.shipping / 100,
          tax:      capturedOrder.tax / 100,
          discount: capturedOrder.discount / 100,
          coupon:   capturedOrder.couponCodes ? capturedOrder.couponCodes[0] : '',
          currency: capturedOrder.currency,
          products: [] as any[],
        };

        for (const item of this.items) {
          let a = {
            id: item.productId,
            sku: item.productSlug,
            name: item.productName,
            quantity: item.quantity,
            price: item.price / 100,
          };

          if (this.analytics)  {
            if (this.analyticsProductTransform != null) {
              a = this.analyticsProductTransform(a)
            }

          }
          options.products.push(a)
        }

        if (this.analytics)  {
          this.analytics.track('Completed Order', options);
        }

        return capturedOrder
      }
    } catch (err) {
      console.log('checkout error', err)

      throw err
    }
  }
}
